<center><font size = 5>排序算法</font></center>

------

```go
//归并排序
func mergeSort(arr []int) {
	mySort(arr, 0, len(arr)-1)
	fmt.Println(arr)
}

func mySort(arr []int, L, R int) {
	if L == R {
		return
	}
	mid := L + (R-L)>>1
	mySort(arr, L, mid)
	mySort(arr, mid+1, R)
	merge(arr, L, mid, R)
}

func merge(arr []int, L, mid, R int) {
	help := make([]int, R-L+1)
	i := 0
	p1 := L
	p2 := mid + 1
	for p1 <= mid && p2 <= R {
		if arr[p1] <= arr[p2] {
			help[i] = arr[p1]
			p1++
		} else {
			help[i] = arr[p2]
			p2++
		}
		i++
	}

	for p1 <= mid {
		help[i] = arr[p1]
		p1++
		i++
	}
	for p2 <= R {
		help[i] = arr[p2]
		p2++
		i++
	}
	for i = 0; i < len(help); i++ {
		arr[L+i] = help[i]
	}
}

```

```go
//快排
func quickSort(arr []int) {
	mySort(arr, 0, len(arr)-1)
	fmt.Println(arr)
}

func mySort(arr []int, l, r int) {
	if l < r {
		rand.Seed(time.Now().UnixNano())
		flag := rand.Intn(r-l+1) + l
		arr[flag], arr[r] = arr[r], arr[flag]
		lr, rl := quick(arr, l, r)
		mySort(arr, l, lr)
		mySort(arr, rl, r)
	}
}

func quick(arr []int, start, end int) (int, int) {
	l := start
	r := end - 1
	i := start
	for i <= r {
		if arr[i] < arr[end] {
			arr[i], arr[l] = arr[l], arr[i]
			l++
			i++
		} else if arr[i] > arr[end] {
			arr[i], arr[r] = arr[r], arr[i]
			r--
		} else {
			i++
		}
	}
	arr[end], arr[r+1] = arr[r+1], arr[end]
	return l - 1, r + 1 + 1
}
```

```go
//堆排序
func heapSort(arr []int) {
	if arr == nil || len(arr) < 2 {
		return
	}
	//for i := 0; i < len(arr); i++ {
	//	heapInsert(arr, i)
	//}
	for i := len(arr) - 1; i > -1; i-- {
		heapify(arr, i, len(arr))
	}
	heapSize := len(arr) - 1
	arr[0], arr[heapSize] = arr[heapSize], arr[0]

	for heapSize > 0 {
		heapify(arr, 0, heapSize)
		heapSize--
		arr[0], arr[heapSize] = arr[heapSize], arr[0]
	}
	fmt.Println(arr)
}

func heapInsert(arr []int, index int) {
	for arr[index] > arr[(index-1)/2] {
		arr[index], arr[(index-1)/2] = arr[(index-1)/2], arr[index]
		index = (index - 1) / 2
	}
}

func heapify(arr []int, index, heapSize int) {
	left := index*2 + 1
	right := left + 1
	for left < heapSize {
		largest := index
		if right < heapSize {
			largest = max(arr, left, right, index)
		} else {
			largest = max(arr, left, index)
		}
		if largest == index {
			break
		}
		arr[index], arr[largest] = arr[largest], arr[index]
		index = largest
		left = index*2 + 1
		right = left + 1
	}
}

func max(arr []int, list ...int) int {
	ans := list[0]
	for _, v := range list {
		if arr[v] > arr[ans] {
			ans = v
		}
	}
	return ans
}
```

```go
//只能买卖一次
func getStock(arr []int) int {
	buy, sell := math.MinInt32, 0

	for _, v := range arr {
		buy = max(buy, 0-v)
		sell = max(sell, buy+v)
	}
	return sell
}

//可以买卖无数次
func getStock1(arr []int) int {
	buy, sell := math.MinInt32, 0

	for _, v := range arr {
		buy = max(buy, sell-v)
		sell = max(sell, buy+v)
	}
	return sell
}

// 只能买卖两次
func getStock3(arr []int) int {
	b1, b2, s1, s2 := math.MinInt32, math.MinInt32, 0, 0
	for _, v := range arr {
		b1 = max(b1, 0-v)
		s1 = max(s1, b1+v)
		b1 = max(b2, s1-v)
		s2 = max(s2, s1+v)
	}
	return s2
}

//只能买卖k次
func getStock4(arr []int, k int) int {
	buy := make([]int, k+1)
	sell := make([]int, k+1)
	for i := 0; i < k+1; i++ {
		buy[i] = math.MinInt32
	}

	for _, v := range arr {
		for i := 0; i < k+1; i++ {
			buy[i] = max(buy[i], sell[i-1]-v)
			sell[i] = max(sell[i], buy[i]+v)
		}
	}
	return sell[k]
}

//包含冷冻期
func getStock5(arr []int) int {
	buy, sellPre, sell := math.MinInt32, 0, 0
	for _, v := range arr {
		buy = max(buy, sellPre-v)
		sellPre, sell = sell, max(sell, buy-v)
	}
	return sell
}

func getStock6(arr []int, fee int) int {
	buy, sell := math.MinInt32, 0

	for _, v := range arr {
		buy = max(buy, sell-v-fee)
		sell = max(sell, buy+v)
	}
	return sell
}

func max(arr ...int) int {
	ans := arr[0]
	for _, v := range arr {
		if ans > v {
			ans = v
		}
	}
	return ans
}
```

```go
//LRU
type Node struct {
	Key   int
	Value int
	pre   *Node
	next  *Node
}

type LRUCache struct {
	limit   int
	HashMap map[int]*Node  /索引
	head    *Node
	end     *Node
}

func Constructor(capacity int) LRUCache {
	lruCache := LRUCache{limit: capacity}
	lruCache.HashMap = make(map[int]*Node, capacity)
	return lruCache
}

func (l *LRUCache) Get(key int) int {
	if v, ok := l.HashMap[key]; ok {
		l.refreshNode(v)
		return v.Value
	} else {
		return -1
	}
}

func (l *LRUCache) Put(key int, value int) {
	if v, ok := l.HashMap[key]; !ok {
		if len(l.HashMap) >= l.limit {
			oldKey := l.removeNode(l.head)
			delete(l.HashMap, oldKey)
		}
		node := Node{Key: key, Value: value}
		l.addNode(&node)
		l.HashMap[key] = &node
	} else {
		v.Value = value
		l.refreshNode(v)
	}
}

func (l *LRUCache) refreshNode(node *Node) {
	if node == l.end {
		return
	}
	l.removeNode(node)
	l.addNode(node)
}

func (l *LRUCache) removeNode(node *Node) int {
	if node == l.end {
		l.end = l.end.pre
	} else if node == l.head {
		l.head = l.head.next
	} else {
		node.pre.next = node.next
		node.next.pre = node.pre
	}
	return node.Key
}

func (l *LRUCache) addNode(node *Node) {
	if l.end != nil {
		l.end.next = node
		node.pre = l.end
		node.next = nil
	}
	l.end = node
	if l.head == nil {
		l.head = node
	}
}

func LRU(operators [][]int, k int) []int {
	// write code here
	ans := make([]int, 0, 10)

	l := Constructor(k)

	for i := 0; i < len(operators); i++ {
		if operators[i][0] == 2 {
			ans = append(ans, l.Get(operators[i][1]))
		} else {
			l.Put(operators[i][1], operators[i][2])
		}
	}
	return ans
}
```

